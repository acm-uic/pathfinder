<html>
<head>
<title> UIC Mega path Finder </title>

<link rel="stylesheet" type="text/css" href="Style.css" />
</head>

<body>
<div id="head"></div>

<div id="left">
<div class="padding2"></div>
  <ul>
    <li><a class="nav" href="../cgi-bin/pathfinder.cgi" title="Pathfinder">Pathfinder</a></li>
    <li><a class="nav" href="about.html" title="About">About</a></li>
    <li><a class="nav" href="faqs.html" title="Frequently Asekd Questions">FAQ's</a></li>
  </ul>
</div>

<div id="content">
<div class="padding2"></div>
</p>

<p>

<h2><div align=center>UMPH - A Path to Success</div></h2>

<p>&nbsp;&nbsp;&nbsp;&nbsp;The purpose of the UIC Pathfinder project was to give a visual representation of the optimal path between locations on campus.  Specifically, given a beginning location and end location, specified by building and room number, we would draw a path between the rooms and display this path to the user.  For this purpose the project could be considered to be a relative success, depending on what your definition optimal is.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;The UIC Pathfinder project was composed of 6 major components.  The first, and easiest, was acquisition of images.  There were many ways to go about this, some requiring more legwork than others, but we were able to get into contact with building services who provided us the fire maps for the buildings we needed.  Some of the rooms we wanted to include were grayed out, as they are not public classrooms, so we decided to respect their wishes and leave out those rooms. </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Using these maps, we progressed into the second phase of the project.  Cleaning up the maps (removing the blue fire escape lines and other artifacts), we generated a set of png files that would be the ones we were to draw our final output on.  Then came the difficult part.  Taking each of the images, we manually inserted nodes which we would use to path our algorithm.  Using Adobe Illustrator, we opened each pdf, and put 4 types of nodes onto the map.  One was a boundary node, so we could calculate the corners and thus the relative positions of the nodes.  One was a room node, which we placed in all for the rooms we wished the user to be able to choose as start and end points.  One was what we called a transfer node, which would represent the transfers between maps, along staircases or to the outside.  The final type of node is one which we had more than triple the other types, which was hallway nodes.  Saving these files in svg format, so that we could extract the location of the nodes as text, we had a sufficient amount of data to begin the real project.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;The third phase of the project was to extract the data from the nodes into a workable format.  For this purpose we wrote our first script, using Python.  We were using Python solely for the processing of text files and the automation of parts of the node creation process, but its use slowly grew to encompass the majority of the project.  The first thing we did was to identify the nodes in the svg file, checking that all the nodes we needed were in the right place and labeled appropriately.  Then we parsed the file using regular expressions and the string find functions in Python.  The data for the placement of the nodes on the picture were in matrix format, so by searching for 6 floating point numbers after a matrix tag we were able to determine our coordinates.  Sean was printing out the data, and storing the information in regular text files.  Tom introduced the idea of storing the files in a cleaner format, xml.  Sean then began to modify the output to fit that format, but Tom found a python module that claimed to be able to do it for us.  The xml module for Python, with its sub modules dom and minidom, could both read and write xml information.  The Document Object Module stores information in a tree format, starting with a document object at the top, and the specific information stored by subject in the leaves.  Each node was a category, and the sets of information were categories beneath the node in the tree.  The minidom module was supposed to be the easiest of the methods for reading and writing the files, but we hit a serious roadblock at this point.  The documentation for the xml module and all of its submodules was lacking in detail and highly confusing to read.  Hours were spent puzzling over the documentation and examples online for how to do simple tasks like write a file and read a file back into a tree, then on how to access the information from the recreated tree.  Eventually, we came to understand the often confusing syntax and applied the minidom module to form our tree of nodes and print out an xml file for each of the pictures.  In addition, we began using a more robust python xml library at this point to read the files and print them out in a visually recognizable format, as the file itself was all on a single line, with no spacing.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;The fourth phase was to actually produce the A* search.  This phase was divided into two parts, the first being to parse the xml files back into usable nodes.  We began by using what we had learned from our struggles first creating the files to read the xml file for the map we wished to search on, and extracting the nodes into local variables.  Using these nodes we implemented a simple A* search on a single map.  Tom used wikipedia to refresh himself on how to program the search, and Sean checked over his work and rewrote the parts that were incorrect using his knowledge from CS 411, Artificial Intelligence.  There were several candidates for the heuristic, including position in world coordinates, 1 for all nodes, and varying constants depending on whether the node was a room, hallway, or transfer, or depending on what type of transfer the node was (staircase/elevator/exit).  Eventually the decision was made that we would use as a heuristic the distance between the current node and the end node, summed with the distance traveled so far as specified in the A* algorithm.  These distances are both in pixels, not converted to world coordinates.  This A* search is the one we used through to the end.  For a while, it was not implemented correctly, as the past distance traveled was not being included in the calculations.  This was an issue that was difficult to determine, and only once we had larger maps and cases working did we successfully identify the issue.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;From here we entered the fifth phase, which was the largest and most difficult portion of the project.  This was the process of expanding the search to handle multiple files.  In this part, our heuristics became a lot more complicated.  One issue is that we were using a heuristic of distance in pixels, and the conversion between files is certainly not one to one.  Another issue is that we need to load from a variety of different files, maintaining an accurate and useful set of border nodes as we go.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;The solution we came up with was a compromise.  Giving up on maintaining a campus wide A* search, we split the search up by map, finding the optimal transfer node to the next map, and then going from there to the next transfer, getting the shortest path on each map that would get us closest to the end position.  Hopping from map to map on what we think is the shortest path is not the overall optimal path; however it should be a close enough approximation that does not push the user far out of the way.  Were we to do an overall A* search, it would take far longer as all of the border nodes out to the end node are explored, ending up with a radius of exploration taking up a large portion of the first building, and likely a fair amount along the way.  Given the time the search takes already, implementing a more precise or exact A* search would likely increase search times beyond acceptable levels.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;It was at this point we began realizing the magnitude of testing our project.  Producing a wrapper class for our project that would make accesses easier and more accessible, we tried implementing code that would test all of the cases.  After many days and nights, we found that the testing had still not completed.  So, with no time to waste, we initiated phase six, designing the UI.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;We considered a number of options for deciding how we wished to display the results of our search to the user.  Choices ranged from only text, describing what direction the user should move or when the user should turn, to pictures or even animation.  Given our algorithms, it was be easier to draw images than to provide a textual guide to the user.  The first order of business then was to find a way to draw the images with lines as a guide for the path.  After some discussion, we decided to try using the Python Imaging Library.  It took a while to install it on all of the machines we were using, but the lines were fairly easy to draw, given that we already had the coordinates of the nodes in pixels.  Specifying the same coordinates that we had written to the xml file, which were in pixels, our image matched the original file we had created.  We encountered a lot more difficulty trying to put text into the document for debugging and data purposes.  We were running the program on the ACM server, which did not have any default fonts installed.  Even when we downloaded some fonts, they were not being accessed or drawn correctly.  After going through 3 different sets of fonts, and with further modification of the code, we managed to get the image being drawn with the name of nodes, especially transfers, being displayed vertically, rising up from the node.  This was necessary for building the transfer list, or the list of nodes that would allow one map to move to the other.  This was quite painful, and would have driven both the authors mad with the tedium without the labels there.  Though the text took a long to implement, the results were definitely worth it.  Also vital to this part was the creation of the Campus number map text file which is where we defined the transfers from the campus map to individual buildings.  The transfers were the glue we needed to paste our maps together.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;With these transfers, we could begin the search across multiple files.  Realizing the limitations already stated with maintaining an overall A* search, Sean began developing an overall search which would handle the logic of crossing between maps and maintaining the state for the search.  This is also where we would have to handle the logic of disjoint maps and other special cases.  When it did finally reach the case where the two nodes were on the same map, it would call the single map A* search on those two nodes, otherwise it would perform some logic to determine how it should act, and then run the single map A* search if it needed to move to a transfer before proceeding to the next map.  Tom on the other hand, developed code to find the transfers between maps, and would return the pair of nodes from this map to the next.  This was vital to making a good search, as the majority of the searches would be to the transfers between maps, not to the final node itself.  With both of these functions, also written in Python, we could begin trying to actually have a product similar to our final product.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Though the searches were not all correct, and our heuristic for between maps and other logic was ill formed, we decided we needed to create a user output to test our results.  The overall search was returning a list of nodes that we had traveled over from start to finish.  Using these results, Sean designed a plan for reading in the nodes one at a time, and based on the content of the node, and some flags set based on previous nodes, that would split the nodes into lists, each list made up of the nodes contained in a single image.  That way, we could call the function we had for drawing a single image iteratively, on each of the new lists.  This would be the basis for how the output would be created.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;We had to communicate using post forms, using the python cgi module.  Running our script through the cgi, we were able to communicate our results through a reasonable web interface, which also provided us a way to quickly and easily get input from the user.  Customizing the Cascading Style Sheet, we were able to whip up a website which would allow us to cleanly display our output while providing as coherent a design as our level of graphical and html expertise would allow.  Tom created the cgi script, as well as implementing the design of the site.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;There was just a bit more that needed to be done before we could begin getting input from other people.  Tom implemented some try catch code that would wrap the errors with hit with nicer &quot;A* search could not be completed&quot; output.  Sean developed a caching system that would store the results in a text file, so that the search would not need to be performed on repeat occasions.  Tom also modified the image storage and retrieval so that images would be stored in a subfolder specific to a search, which would prevent collisions occurring with multiple users.  Once we had a somewhat user friendly output, we began asking other people to test out our script.  This included sending out a message to the ACM at UIC's mailing list, to have those with an interest in computers and computing methods so that they could test out our script and find errors in our project.  That way, we could get results from a variety of people and situations, allowing us to detect errors and parts of the code which would require modification.  This input allowed us to improve our heuristic for choosing transfers in a building, and identify how to choose good exits and entrances to buildings.  Also this is how we figured out we were not parsing the strings for the file names correctly, as most of the maps had a floor number appended to the end, but certain files did not and we were not handling it correctly.  This is also where we found out about visual oddities with the lines being drawn, which meant we needed to modify our image drawing function.  Certain unusual paths also presented themselves, which was the first sign we received that the single map A* search was not being done correctly, as the history of the path traveled was not being accounted for in the heuristic.  This stage is essentially the final stage, as any errors at this point are handled on a case by case basis, carefully modifying the search to fix cases that were not counted for in the function's original inception.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;There are still some specific cases of the data being incorrectly handled, but though further testing and input from users, these cases can be fixed and the product should be a useful tool for all those trying to find classrooms on the east side of campus, as well as being a prototype for producing maps of other places.</p>

<p>
At any rate, we hope you enjoy our project,<br>
Tom Sakkos and Sean Deitz<br>
Advisor: Professor Mitch Theys<br>
http://acm.cs.uic.edu/umpf
</p>
 


<div class="padding2"></div>
</div>

</body>
</html>
